// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: dfs.proto
#ifndef GRPC_dfs_2eproto__INCLUDED
#define GRPC_dfs_2eproto__INCLUDED

#include "dfs.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>
#include <grpcpp/ports_def.inc>

namespace dfs {

// ===========================================================
//  Servicio NameNode <-> Cliente
// ===========================================================
class NameNodeService final {
 public:
  static constexpr char const* service_full_name() {
    return "dfs.NameNodeService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Subir un archivo: cliente indica nombre y tamaño, NN responde con asignación de bloques
    virtual ::grpc::Status PutFile(::grpc::ClientContext* context, const ::dfs::PutFileRequest& request, ::dfs::PutFileResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::PutFileResponse>> AsyncPutFile(::grpc::ClientContext* context, const ::dfs::PutFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::PutFileResponse>>(AsyncPutFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::PutFileResponse>> PrepareAsyncPutFile(::grpc::ClientContext* context, const ::dfs::PutFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::PutFileResponse>>(PrepareAsyncPutFileRaw(context, request, cq));
    }
    // Descargar un archivo: cliente pide info de bloques
    virtual ::grpc::Status GetFile(::grpc::ClientContext* context, const ::dfs::GetFileRequest& request, ::dfs::GetFileResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::GetFileResponse>> AsyncGetFile(::grpc::ClientContext* context, const ::dfs::GetFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::GetFileResponse>>(AsyncGetFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::GetFileResponse>> PrepareAsyncGetFile(::grpc::ClientContext* context, const ::dfs::GetFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::GetFileResponse>>(PrepareAsyncGetFileRaw(context, request, cq));
    }
    // Listar archivos del usuario
    virtual ::grpc::Status ListFiles(::grpc::ClientContext* context, const ::dfs::ListFilesRequest& request, ::dfs::ListFilesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::ListFilesResponse>> AsyncListFiles(::grpc::ClientContext* context, const ::dfs::ListFilesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::ListFilesResponse>>(AsyncListFilesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::ListFilesResponse>> PrepareAsyncListFiles(::grpc::ClientContext* context, const ::dfs::ListFilesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::ListFilesResponse>>(PrepareAsyncListFilesRaw(context, request, cq));
    }
    // Eliminar un archivo
    virtual ::grpc::Status RemoveFile(::grpc::ClientContext* context, const ::dfs::RemoveFileRequest& request, ::dfs::RemoveFileResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::RemoveFileResponse>> AsyncRemoveFile(::grpc::ClientContext* context, const ::dfs::RemoveFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::RemoveFileResponse>>(AsyncRemoveFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::RemoveFileResponse>> PrepareAsyncRemoveFile(::grpc::ClientContext* context, const ::dfs::RemoveFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::RemoveFileResponse>>(PrepareAsyncRemoveFileRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Subir un archivo: cliente indica nombre y tamaño, NN responde con asignación de bloques
      virtual void PutFile(::grpc::ClientContext* context, const ::dfs::PutFileRequest* request, ::dfs::PutFileResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PutFile(::grpc::ClientContext* context, const ::dfs::PutFileRequest* request, ::dfs::PutFileResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Descargar un archivo: cliente pide info de bloques
      virtual void GetFile(::grpc::ClientContext* context, const ::dfs::GetFileRequest* request, ::dfs::GetFileResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetFile(::grpc::ClientContext* context, const ::dfs::GetFileRequest* request, ::dfs::GetFileResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Listar archivos del usuario
      virtual void ListFiles(::grpc::ClientContext* context, const ::dfs::ListFilesRequest* request, ::dfs::ListFilesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListFiles(::grpc::ClientContext* context, const ::dfs::ListFilesRequest* request, ::dfs::ListFilesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Eliminar un archivo
      virtual void RemoveFile(::grpc::ClientContext* context, const ::dfs::RemoveFileRequest* request, ::dfs::RemoveFileResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RemoveFile(::grpc::ClientContext* context, const ::dfs::RemoveFileRequest* request, ::dfs::RemoveFileResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::PutFileResponse>* AsyncPutFileRaw(::grpc::ClientContext* context, const ::dfs::PutFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::PutFileResponse>* PrepareAsyncPutFileRaw(::grpc::ClientContext* context, const ::dfs::PutFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::GetFileResponse>* AsyncGetFileRaw(::grpc::ClientContext* context, const ::dfs::GetFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::GetFileResponse>* PrepareAsyncGetFileRaw(::grpc::ClientContext* context, const ::dfs::GetFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::ListFilesResponse>* AsyncListFilesRaw(::grpc::ClientContext* context, const ::dfs::ListFilesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::ListFilesResponse>* PrepareAsyncListFilesRaw(::grpc::ClientContext* context, const ::dfs::ListFilesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::RemoveFileResponse>* AsyncRemoveFileRaw(::grpc::ClientContext* context, const ::dfs::RemoveFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::RemoveFileResponse>* PrepareAsyncRemoveFileRaw(::grpc::ClientContext* context, const ::dfs::RemoveFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status PutFile(::grpc::ClientContext* context, const ::dfs::PutFileRequest& request, ::dfs::PutFileResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::PutFileResponse>> AsyncPutFile(::grpc::ClientContext* context, const ::dfs::PutFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::PutFileResponse>>(AsyncPutFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::PutFileResponse>> PrepareAsyncPutFile(::grpc::ClientContext* context, const ::dfs::PutFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::PutFileResponse>>(PrepareAsyncPutFileRaw(context, request, cq));
    }
    ::grpc::Status GetFile(::grpc::ClientContext* context, const ::dfs::GetFileRequest& request, ::dfs::GetFileResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::GetFileResponse>> AsyncGetFile(::grpc::ClientContext* context, const ::dfs::GetFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::GetFileResponse>>(AsyncGetFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::GetFileResponse>> PrepareAsyncGetFile(::grpc::ClientContext* context, const ::dfs::GetFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::GetFileResponse>>(PrepareAsyncGetFileRaw(context, request, cq));
    }
    ::grpc::Status ListFiles(::grpc::ClientContext* context, const ::dfs::ListFilesRequest& request, ::dfs::ListFilesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::ListFilesResponse>> AsyncListFiles(::grpc::ClientContext* context, const ::dfs::ListFilesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::ListFilesResponse>>(AsyncListFilesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::ListFilesResponse>> PrepareAsyncListFiles(::grpc::ClientContext* context, const ::dfs::ListFilesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::ListFilesResponse>>(PrepareAsyncListFilesRaw(context, request, cq));
    }
    ::grpc::Status RemoveFile(::grpc::ClientContext* context, const ::dfs::RemoveFileRequest& request, ::dfs::RemoveFileResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::RemoveFileResponse>> AsyncRemoveFile(::grpc::ClientContext* context, const ::dfs::RemoveFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::RemoveFileResponse>>(AsyncRemoveFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::RemoveFileResponse>> PrepareAsyncRemoveFile(::grpc::ClientContext* context, const ::dfs::RemoveFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::RemoveFileResponse>>(PrepareAsyncRemoveFileRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void PutFile(::grpc::ClientContext* context, const ::dfs::PutFileRequest* request, ::dfs::PutFileResponse* response, std::function<void(::grpc::Status)>) override;
      void PutFile(::grpc::ClientContext* context, const ::dfs::PutFileRequest* request, ::dfs::PutFileResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetFile(::grpc::ClientContext* context, const ::dfs::GetFileRequest* request, ::dfs::GetFileResponse* response, std::function<void(::grpc::Status)>) override;
      void GetFile(::grpc::ClientContext* context, const ::dfs::GetFileRequest* request, ::dfs::GetFileResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ListFiles(::grpc::ClientContext* context, const ::dfs::ListFilesRequest* request, ::dfs::ListFilesResponse* response, std::function<void(::grpc::Status)>) override;
      void ListFiles(::grpc::ClientContext* context, const ::dfs::ListFilesRequest* request, ::dfs::ListFilesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RemoveFile(::grpc::ClientContext* context, const ::dfs::RemoveFileRequest* request, ::dfs::RemoveFileResponse* response, std::function<void(::grpc::Status)>) override;
      void RemoveFile(::grpc::ClientContext* context, const ::dfs::RemoveFileRequest* request, ::dfs::RemoveFileResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::dfs::PutFileResponse>* AsyncPutFileRaw(::grpc::ClientContext* context, const ::dfs::PutFileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::PutFileResponse>* PrepareAsyncPutFileRaw(::grpc::ClientContext* context, const ::dfs::PutFileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::GetFileResponse>* AsyncGetFileRaw(::grpc::ClientContext* context, const ::dfs::GetFileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::GetFileResponse>* PrepareAsyncGetFileRaw(::grpc::ClientContext* context, const ::dfs::GetFileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::ListFilesResponse>* AsyncListFilesRaw(::grpc::ClientContext* context, const ::dfs::ListFilesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::ListFilesResponse>* PrepareAsyncListFilesRaw(::grpc::ClientContext* context, const ::dfs::ListFilesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::RemoveFileResponse>* AsyncRemoveFileRaw(::grpc::ClientContext* context, const ::dfs::RemoveFileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::RemoveFileResponse>* PrepareAsyncRemoveFileRaw(::grpc::ClientContext* context, const ::dfs::RemoveFileRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_PutFile_;
    const ::grpc::internal::RpcMethod rpcmethod_GetFile_;
    const ::grpc::internal::RpcMethod rpcmethod_ListFiles_;
    const ::grpc::internal::RpcMethod rpcmethod_RemoveFile_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Subir un archivo: cliente indica nombre y tamaño, NN responde con asignación de bloques
    virtual ::grpc::Status PutFile(::grpc::ServerContext* context, const ::dfs::PutFileRequest* request, ::dfs::PutFileResponse* response);
    // Descargar un archivo: cliente pide info de bloques
    virtual ::grpc::Status GetFile(::grpc::ServerContext* context, const ::dfs::GetFileRequest* request, ::dfs::GetFileResponse* response);
    // Listar archivos del usuario
    virtual ::grpc::Status ListFiles(::grpc::ServerContext* context, const ::dfs::ListFilesRequest* request, ::dfs::ListFilesResponse* response);
    // Eliminar un archivo
    virtual ::grpc::Status RemoveFile(::grpc::ServerContext* context, const ::dfs::RemoveFileRequest* request, ::dfs::RemoveFileResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_PutFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PutFile() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_PutFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutFile(::grpc::ServerContext* /*context*/, const ::dfs::PutFileRequest* /*request*/, ::dfs::PutFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPutFile(::grpc::ServerContext* context, ::dfs::PutFileRequest* request, ::grpc::ServerAsyncResponseWriter< ::dfs::PutFileResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetFile() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFile(::grpc::ServerContext* /*context*/, const ::dfs::GetFileRequest* /*request*/, ::dfs::GetFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFile(::grpc::ServerContext* context, ::dfs::GetFileRequest* request, ::grpc::ServerAsyncResponseWriter< ::dfs::GetFileResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListFiles() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_ListFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListFiles(::grpc::ServerContext* /*context*/, const ::dfs::ListFilesRequest* /*request*/, ::dfs::ListFilesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListFiles(::grpc::ServerContext* context, ::dfs::ListFilesRequest* request, ::grpc::ServerAsyncResponseWriter< ::dfs::ListFilesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RemoveFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RemoveFile() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_RemoveFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveFile(::grpc::ServerContext* /*context*/, const ::dfs::RemoveFileRequest* /*request*/, ::dfs::RemoveFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveFile(::grpc::ServerContext* context, ::dfs::RemoveFileRequest* request, ::grpc::ServerAsyncResponseWriter< ::dfs::RemoveFileResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_PutFile<WithAsyncMethod_GetFile<WithAsyncMethod_ListFiles<WithAsyncMethod_RemoveFile<Service > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_PutFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PutFile() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::dfs::PutFileRequest, ::dfs::PutFileResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dfs::PutFileRequest* request, ::dfs::PutFileResponse* response) { return this->PutFile(context, request, response); }));}
    void SetMessageAllocatorFor_PutFile(
        ::grpc::MessageAllocator< ::dfs::PutFileRequest, ::dfs::PutFileResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dfs::PutFileRequest, ::dfs::PutFileResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PutFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutFile(::grpc::ServerContext* /*context*/, const ::dfs::PutFileRequest* /*request*/, ::dfs::PutFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PutFile(
      ::grpc::CallbackServerContext* /*context*/, const ::dfs::PutFileRequest* /*request*/, ::dfs::PutFileResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetFile() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::dfs::GetFileRequest, ::dfs::GetFileResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dfs::GetFileRequest* request, ::dfs::GetFileResponse* response) { return this->GetFile(context, request, response); }));}
    void SetMessageAllocatorFor_GetFile(
        ::grpc::MessageAllocator< ::dfs::GetFileRequest, ::dfs::GetFileResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dfs::GetFileRequest, ::dfs::GetFileResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFile(::grpc::ServerContext* /*context*/, const ::dfs::GetFileRequest* /*request*/, ::dfs::GetFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetFile(
      ::grpc::CallbackServerContext* /*context*/, const ::dfs::GetFileRequest* /*request*/, ::dfs::GetFileResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ListFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ListFiles() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::dfs::ListFilesRequest, ::dfs::ListFilesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dfs::ListFilesRequest* request, ::dfs::ListFilesResponse* response) { return this->ListFiles(context, request, response); }));}
    void SetMessageAllocatorFor_ListFiles(
        ::grpc::MessageAllocator< ::dfs::ListFilesRequest, ::dfs::ListFilesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dfs::ListFilesRequest, ::dfs::ListFilesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ListFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListFiles(::grpc::ServerContext* /*context*/, const ::dfs::ListFilesRequest* /*request*/, ::dfs::ListFilesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListFiles(
      ::grpc::CallbackServerContext* /*context*/, const ::dfs::ListFilesRequest* /*request*/, ::dfs::ListFilesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RemoveFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RemoveFile() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::dfs::RemoveFileRequest, ::dfs::RemoveFileResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dfs::RemoveFileRequest* request, ::dfs::RemoveFileResponse* response) { return this->RemoveFile(context, request, response); }));}
    void SetMessageAllocatorFor_RemoveFile(
        ::grpc::MessageAllocator< ::dfs::RemoveFileRequest, ::dfs::RemoveFileResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dfs::RemoveFileRequest, ::dfs::RemoveFileResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RemoveFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveFile(::grpc::ServerContext* /*context*/, const ::dfs::RemoveFileRequest* /*request*/, ::dfs::RemoveFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RemoveFile(
      ::grpc::CallbackServerContext* /*context*/, const ::dfs::RemoveFileRequest* /*request*/, ::dfs::RemoveFileResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_PutFile<WithCallbackMethod_GetFile<WithCallbackMethod_ListFiles<WithCallbackMethod_RemoveFile<Service > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_PutFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PutFile() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_PutFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutFile(::grpc::ServerContext* /*context*/, const ::dfs::PutFileRequest* /*request*/, ::dfs::PutFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetFile() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFile(::grpc::ServerContext* /*context*/, const ::dfs::GetFileRequest* /*request*/, ::dfs::GetFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListFiles() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_ListFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListFiles(::grpc::ServerContext* /*context*/, const ::dfs::ListFilesRequest* /*request*/, ::dfs::ListFilesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RemoveFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RemoveFile() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_RemoveFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveFile(::grpc::ServerContext* /*context*/, const ::dfs::RemoveFileRequest* /*request*/, ::dfs::RemoveFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_PutFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PutFile() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_PutFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutFile(::grpc::ServerContext* /*context*/, const ::dfs::PutFileRequest* /*request*/, ::dfs::PutFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPutFile(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetFile() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFile(::grpc::ServerContext* /*context*/, const ::dfs::GetFileRequest* /*request*/, ::dfs::GetFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFile(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListFiles() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_ListFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListFiles(::grpc::ServerContext* /*context*/, const ::dfs::ListFilesRequest* /*request*/, ::dfs::ListFilesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListFiles(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RemoveFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RemoveFile() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_RemoveFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveFile(::grpc::ServerContext* /*context*/, const ::dfs::RemoveFileRequest* /*request*/, ::dfs::RemoveFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveFile(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PutFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PutFile() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PutFile(context, request, response); }));
    }
    ~WithRawCallbackMethod_PutFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutFile(::grpc::ServerContext* /*context*/, const ::dfs::PutFileRequest* /*request*/, ::dfs::PutFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PutFile(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetFile() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetFile(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFile(::grpc::ServerContext* /*context*/, const ::dfs::GetFileRequest* /*request*/, ::dfs::GetFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetFile(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ListFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ListFiles() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListFiles(context, request, response); }));
    }
    ~WithRawCallbackMethod_ListFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListFiles(::grpc::ServerContext* /*context*/, const ::dfs::ListFilesRequest* /*request*/, ::dfs::ListFilesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListFiles(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RemoveFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RemoveFile() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RemoveFile(context, request, response); }));
    }
    ~WithRawCallbackMethod_RemoveFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveFile(::grpc::ServerContext* /*context*/, const ::dfs::RemoveFileRequest* /*request*/, ::dfs::RemoveFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RemoveFile(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PutFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PutFile() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dfs::PutFileRequest, ::dfs::PutFileResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dfs::PutFileRequest, ::dfs::PutFileResponse>* streamer) {
                       return this->StreamedPutFile(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PutFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PutFile(::grpc::ServerContext* /*context*/, const ::dfs::PutFileRequest* /*request*/, ::dfs::PutFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPutFile(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dfs::PutFileRequest,::dfs::PutFileResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetFile() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dfs::GetFileRequest, ::dfs::GetFileResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dfs::GetFileRequest, ::dfs::GetFileResponse>* streamer) {
                       return this->StreamedGetFile(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetFile(::grpc::ServerContext* /*context*/, const ::dfs::GetFileRequest* /*request*/, ::dfs::GetFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetFile(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dfs::GetFileRequest,::dfs::GetFileResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListFiles() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dfs::ListFilesRequest, ::dfs::ListFilesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dfs::ListFilesRequest, ::dfs::ListFilesResponse>* streamer) {
                       return this->StreamedListFiles(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListFiles(::grpc::ServerContext* /*context*/, const ::dfs::ListFilesRequest* /*request*/, ::dfs::ListFilesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListFiles(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dfs::ListFilesRequest,::dfs::ListFilesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RemoveFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RemoveFile() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dfs::RemoveFileRequest, ::dfs::RemoveFileResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dfs::RemoveFileRequest, ::dfs::RemoveFileResponse>* streamer) {
                       return this->StreamedRemoveFile(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RemoveFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RemoveFile(::grpc::ServerContext* /*context*/, const ::dfs::RemoveFileRequest* /*request*/, ::dfs::RemoveFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRemoveFile(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dfs::RemoveFileRequest,::dfs::RemoveFileResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_PutFile<WithStreamedUnaryMethod_GetFile<WithStreamedUnaryMethod_ListFiles<WithStreamedUnaryMethod_RemoveFile<Service > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_PutFile<WithStreamedUnaryMethod_GetFile<WithStreamedUnaryMethod_ListFiles<WithStreamedUnaryMethod_RemoveFile<Service > > > > StreamedService;
};

// ===========================================================
//  Servicio Cliente <-> DataNode
// ===========================================================
class DataNodeService final {
 public:
  static constexpr char const* service_full_name() {
    return "dfs.DataNodeService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Subir un bloque a un DataNode
    virtual ::grpc::Status UploadBlock(::grpc::ClientContext* context, const ::dfs::BlockUploadRequest& request, ::dfs::BlockUploadResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::BlockUploadResponse>> AsyncUploadBlock(::grpc::ClientContext* context, const ::dfs::BlockUploadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::BlockUploadResponse>>(AsyncUploadBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::BlockUploadResponse>> PrepareAsyncUploadBlock(::grpc::ClientContext* context, const ::dfs::BlockUploadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::BlockUploadResponse>>(PrepareAsyncUploadBlockRaw(context, request, cq));
    }
    // Descargar un bloque desde un DataNode
    virtual ::grpc::Status DownloadBlock(::grpc::ClientContext* context, const ::dfs::BlockDownloadRequest& request, ::dfs::BlockDownloadResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::BlockDownloadResponse>> AsyncDownloadBlock(::grpc::ClientContext* context, const ::dfs::BlockDownloadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::BlockDownloadResponse>>(AsyncDownloadBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::BlockDownloadResponse>> PrepareAsyncDownloadBlock(::grpc::ClientContext* context, const ::dfs::BlockDownloadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::BlockDownloadResponse>>(PrepareAsyncDownloadBlockRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Subir un bloque a un DataNode
      virtual void UploadBlock(::grpc::ClientContext* context, const ::dfs::BlockUploadRequest* request, ::dfs::BlockUploadResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UploadBlock(::grpc::ClientContext* context, const ::dfs::BlockUploadRequest* request, ::dfs::BlockUploadResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Descargar un bloque desde un DataNode
      virtual void DownloadBlock(::grpc::ClientContext* context, const ::dfs::BlockDownloadRequest* request, ::dfs::BlockDownloadResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DownloadBlock(::grpc::ClientContext* context, const ::dfs::BlockDownloadRequest* request, ::dfs::BlockDownloadResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::BlockUploadResponse>* AsyncUploadBlockRaw(::grpc::ClientContext* context, const ::dfs::BlockUploadRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::BlockUploadResponse>* PrepareAsyncUploadBlockRaw(::grpc::ClientContext* context, const ::dfs::BlockUploadRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::BlockDownloadResponse>* AsyncDownloadBlockRaw(::grpc::ClientContext* context, const ::dfs::BlockDownloadRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::BlockDownloadResponse>* PrepareAsyncDownloadBlockRaw(::grpc::ClientContext* context, const ::dfs::BlockDownloadRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status UploadBlock(::grpc::ClientContext* context, const ::dfs::BlockUploadRequest& request, ::dfs::BlockUploadResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::BlockUploadResponse>> AsyncUploadBlock(::grpc::ClientContext* context, const ::dfs::BlockUploadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::BlockUploadResponse>>(AsyncUploadBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::BlockUploadResponse>> PrepareAsyncUploadBlock(::grpc::ClientContext* context, const ::dfs::BlockUploadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::BlockUploadResponse>>(PrepareAsyncUploadBlockRaw(context, request, cq));
    }
    ::grpc::Status DownloadBlock(::grpc::ClientContext* context, const ::dfs::BlockDownloadRequest& request, ::dfs::BlockDownloadResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::BlockDownloadResponse>> AsyncDownloadBlock(::grpc::ClientContext* context, const ::dfs::BlockDownloadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::BlockDownloadResponse>>(AsyncDownloadBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::BlockDownloadResponse>> PrepareAsyncDownloadBlock(::grpc::ClientContext* context, const ::dfs::BlockDownloadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::BlockDownloadResponse>>(PrepareAsyncDownloadBlockRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void UploadBlock(::grpc::ClientContext* context, const ::dfs::BlockUploadRequest* request, ::dfs::BlockUploadResponse* response, std::function<void(::grpc::Status)>) override;
      void UploadBlock(::grpc::ClientContext* context, const ::dfs::BlockUploadRequest* request, ::dfs::BlockUploadResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DownloadBlock(::grpc::ClientContext* context, const ::dfs::BlockDownloadRequest* request, ::dfs::BlockDownloadResponse* response, std::function<void(::grpc::Status)>) override;
      void DownloadBlock(::grpc::ClientContext* context, const ::dfs::BlockDownloadRequest* request, ::dfs::BlockDownloadResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::dfs::BlockUploadResponse>* AsyncUploadBlockRaw(::grpc::ClientContext* context, const ::dfs::BlockUploadRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::BlockUploadResponse>* PrepareAsyncUploadBlockRaw(::grpc::ClientContext* context, const ::dfs::BlockUploadRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::BlockDownloadResponse>* AsyncDownloadBlockRaw(::grpc::ClientContext* context, const ::dfs::BlockDownloadRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::BlockDownloadResponse>* PrepareAsyncDownloadBlockRaw(::grpc::ClientContext* context, const ::dfs::BlockDownloadRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_UploadBlock_;
    const ::grpc::internal::RpcMethod rpcmethod_DownloadBlock_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Subir un bloque a un DataNode
    virtual ::grpc::Status UploadBlock(::grpc::ServerContext* context, const ::dfs::BlockUploadRequest* request, ::dfs::BlockUploadResponse* response);
    // Descargar un bloque desde un DataNode
    virtual ::grpc::Status DownloadBlock(::grpc::ServerContext* context, const ::dfs::BlockDownloadRequest* request, ::dfs::BlockDownloadResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_UploadBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UploadBlock() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_UploadBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadBlock(::grpc::ServerContext* /*context*/, const ::dfs::BlockUploadRequest* /*request*/, ::dfs::BlockUploadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUploadBlock(::grpc::ServerContext* context, ::dfs::BlockUploadRequest* request, ::grpc::ServerAsyncResponseWriter< ::dfs::BlockUploadResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DownloadBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DownloadBlock() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_DownloadBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadBlock(::grpc::ServerContext* /*context*/, const ::dfs::BlockDownloadRequest* /*request*/, ::dfs::BlockDownloadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDownloadBlock(::grpc::ServerContext* context, ::dfs::BlockDownloadRequest* request, ::grpc::ServerAsyncResponseWriter< ::dfs::BlockDownloadResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_UploadBlock<WithAsyncMethod_DownloadBlock<Service > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_UploadBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UploadBlock() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::dfs::BlockUploadRequest, ::dfs::BlockUploadResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dfs::BlockUploadRequest* request, ::dfs::BlockUploadResponse* response) { return this->UploadBlock(context, request, response); }));}
    void SetMessageAllocatorFor_UploadBlock(
        ::grpc::MessageAllocator< ::dfs::BlockUploadRequest, ::dfs::BlockUploadResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dfs::BlockUploadRequest, ::dfs::BlockUploadResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UploadBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadBlock(::grpc::ServerContext* /*context*/, const ::dfs::BlockUploadRequest* /*request*/, ::dfs::BlockUploadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UploadBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::dfs::BlockUploadRequest* /*request*/, ::dfs::BlockUploadResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DownloadBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DownloadBlock() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::dfs::BlockDownloadRequest, ::dfs::BlockDownloadResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dfs::BlockDownloadRequest* request, ::dfs::BlockDownloadResponse* response) { return this->DownloadBlock(context, request, response); }));}
    void SetMessageAllocatorFor_DownloadBlock(
        ::grpc::MessageAllocator< ::dfs::BlockDownloadRequest, ::dfs::BlockDownloadResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dfs::BlockDownloadRequest, ::dfs::BlockDownloadResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DownloadBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadBlock(::grpc::ServerContext* /*context*/, const ::dfs::BlockDownloadRequest* /*request*/, ::dfs::BlockDownloadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DownloadBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::dfs::BlockDownloadRequest* /*request*/, ::dfs::BlockDownloadResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_UploadBlock<WithCallbackMethod_DownloadBlock<Service > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_UploadBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UploadBlock() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_UploadBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadBlock(::grpc::ServerContext* /*context*/, const ::dfs::BlockUploadRequest* /*request*/, ::dfs::BlockUploadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DownloadBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DownloadBlock() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_DownloadBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadBlock(::grpc::ServerContext* /*context*/, const ::dfs::BlockDownloadRequest* /*request*/, ::dfs::BlockDownloadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_UploadBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UploadBlock() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_UploadBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadBlock(::grpc::ServerContext* /*context*/, const ::dfs::BlockUploadRequest* /*request*/, ::dfs::BlockUploadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUploadBlock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DownloadBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DownloadBlock() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_DownloadBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadBlock(::grpc::ServerContext* /*context*/, const ::dfs::BlockDownloadRequest* /*request*/, ::dfs::BlockDownloadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDownloadBlock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UploadBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UploadBlock() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UploadBlock(context, request, response); }));
    }
    ~WithRawCallbackMethod_UploadBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadBlock(::grpc::ServerContext* /*context*/, const ::dfs::BlockUploadRequest* /*request*/, ::dfs::BlockUploadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UploadBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DownloadBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DownloadBlock() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DownloadBlock(context, request, response); }));
    }
    ~WithRawCallbackMethod_DownloadBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DownloadBlock(::grpc::ServerContext* /*context*/, const ::dfs::BlockDownloadRequest* /*request*/, ::dfs::BlockDownloadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DownloadBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UploadBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UploadBlock() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dfs::BlockUploadRequest, ::dfs::BlockUploadResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dfs::BlockUploadRequest, ::dfs::BlockUploadResponse>* streamer) {
                       return this->StreamedUploadBlock(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UploadBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UploadBlock(::grpc::ServerContext* /*context*/, const ::dfs::BlockUploadRequest* /*request*/, ::dfs::BlockUploadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUploadBlock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dfs::BlockUploadRequest,::dfs::BlockUploadResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DownloadBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DownloadBlock() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dfs::BlockDownloadRequest, ::dfs::BlockDownloadResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dfs::BlockDownloadRequest, ::dfs::BlockDownloadResponse>* streamer) {
                       return this->StreamedDownloadBlock(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DownloadBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DownloadBlock(::grpc::ServerContext* /*context*/, const ::dfs::BlockDownloadRequest* /*request*/, ::dfs::BlockDownloadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDownloadBlock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dfs::BlockDownloadRequest,::dfs::BlockDownloadResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_UploadBlock<WithStreamedUnaryMethod_DownloadBlock<Service > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_UploadBlock<WithStreamedUnaryMethod_DownloadBlock<Service > > StreamedService;
};

// ===========================================================
//  Servicio interno NameNode <-> DataNodes (Cluster Management)
// ===========================================================
class ClusterService final {
 public:
  static constexpr char const* service_full_name() {
    return "dfs.ClusterService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Registro inicial de un DataNode
    virtual ::grpc::Status RegisterDataNode(::grpc::ClientContext* context, const ::dfs::RegisterDataNodeRequest& request, ::dfs::RegisterDataNodeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::RegisterDataNodeResponse>> AsyncRegisterDataNode(::grpc::ClientContext* context, const ::dfs::RegisterDataNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::RegisterDataNodeResponse>>(AsyncRegisterDataNodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::RegisterDataNodeResponse>> PrepareAsyncRegisterDataNode(::grpc::ClientContext* context, const ::dfs::RegisterDataNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::RegisterDataNodeResponse>>(PrepareAsyncRegisterDataNodeRaw(context, request, cq));
    }
    // Heartbeat: DataNode avisa que sigue activo
    virtual ::grpc::Status Heartbeat(::grpc::ClientContext* context, const ::dfs::HeartbeatRequest& request, ::dfs::HeartbeatResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::HeartbeatResponse>> AsyncHeartbeat(::grpc::ClientContext* context, const ::dfs::HeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::HeartbeatResponse>>(AsyncHeartbeatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::HeartbeatResponse>> PrepareAsyncHeartbeat(::grpc::ClientContext* context, const ::dfs::HeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::HeartbeatResponse>>(PrepareAsyncHeartbeatRaw(context, request, cq));
    }
    // Reporte de bloques almacenados
    virtual ::grpc::Status ReportBlock(::grpc::ClientContext* context, const ::dfs::ReportBlockRequest& request, ::dfs::ReportBlockResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::ReportBlockResponse>> AsyncReportBlock(::grpc::ClientContext* context, const ::dfs::ReportBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::ReportBlockResponse>>(AsyncReportBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::ReportBlockResponse>> PrepareAsyncReportBlock(::grpc::ClientContext* context, const ::dfs::ReportBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::dfs::ReportBlockResponse>>(PrepareAsyncReportBlockRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Registro inicial de un DataNode
      virtual void RegisterDataNode(::grpc::ClientContext* context, const ::dfs::RegisterDataNodeRequest* request, ::dfs::RegisterDataNodeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RegisterDataNode(::grpc::ClientContext* context, const ::dfs::RegisterDataNodeRequest* request, ::dfs::RegisterDataNodeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Heartbeat: DataNode avisa que sigue activo
      virtual void Heartbeat(::grpc::ClientContext* context, const ::dfs::HeartbeatRequest* request, ::dfs::HeartbeatResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Heartbeat(::grpc::ClientContext* context, const ::dfs::HeartbeatRequest* request, ::dfs::HeartbeatResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Reporte de bloques almacenados
      virtual void ReportBlock(::grpc::ClientContext* context, const ::dfs::ReportBlockRequest* request, ::dfs::ReportBlockResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ReportBlock(::grpc::ClientContext* context, const ::dfs::ReportBlockRequest* request, ::dfs::ReportBlockResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::RegisterDataNodeResponse>* AsyncRegisterDataNodeRaw(::grpc::ClientContext* context, const ::dfs::RegisterDataNodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::RegisterDataNodeResponse>* PrepareAsyncRegisterDataNodeRaw(::grpc::ClientContext* context, const ::dfs::RegisterDataNodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::HeartbeatResponse>* AsyncHeartbeatRaw(::grpc::ClientContext* context, const ::dfs::HeartbeatRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::HeartbeatResponse>* PrepareAsyncHeartbeatRaw(::grpc::ClientContext* context, const ::dfs::HeartbeatRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::ReportBlockResponse>* AsyncReportBlockRaw(::grpc::ClientContext* context, const ::dfs::ReportBlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::dfs::ReportBlockResponse>* PrepareAsyncReportBlockRaw(::grpc::ClientContext* context, const ::dfs::ReportBlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status RegisterDataNode(::grpc::ClientContext* context, const ::dfs::RegisterDataNodeRequest& request, ::dfs::RegisterDataNodeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::RegisterDataNodeResponse>> AsyncRegisterDataNode(::grpc::ClientContext* context, const ::dfs::RegisterDataNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::RegisterDataNodeResponse>>(AsyncRegisterDataNodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::RegisterDataNodeResponse>> PrepareAsyncRegisterDataNode(::grpc::ClientContext* context, const ::dfs::RegisterDataNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::RegisterDataNodeResponse>>(PrepareAsyncRegisterDataNodeRaw(context, request, cq));
    }
    ::grpc::Status Heartbeat(::grpc::ClientContext* context, const ::dfs::HeartbeatRequest& request, ::dfs::HeartbeatResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::HeartbeatResponse>> AsyncHeartbeat(::grpc::ClientContext* context, const ::dfs::HeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::HeartbeatResponse>>(AsyncHeartbeatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::HeartbeatResponse>> PrepareAsyncHeartbeat(::grpc::ClientContext* context, const ::dfs::HeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::HeartbeatResponse>>(PrepareAsyncHeartbeatRaw(context, request, cq));
    }
    ::grpc::Status ReportBlock(::grpc::ClientContext* context, const ::dfs::ReportBlockRequest& request, ::dfs::ReportBlockResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::ReportBlockResponse>> AsyncReportBlock(::grpc::ClientContext* context, const ::dfs::ReportBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::ReportBlockResponse>>(AsyncReportBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::ReportBlockResponse>> PrepareAsyncReportBlock(::grpc::ClientContext* context, const ::dfs::ReportBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::dfs::ReportBlockResponse>>(PrepareAsyncReportBlockRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void RegisterDataNode(::grpc::ClientContext* context, const ::dfs::RegisterDataNodeRequest* request, ::dfs::RegisterDataNodeResponse* response, std::function<void(::grpc::Status)>) override;
      void RegisterDataNode(::grpc::ClientContext* context, const ::dfs::RegisterDataNodeRequest* request, ::dfs::RegisterDataNodeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Heartbeat(::grpc::ClientContext* context, const ::dfs::HeartbeatRequest* request, ::dfs::HeartbeatResponse* response, std::function<void(::grpc::Status)>) override;
      void Heartbeat(::grpc::ClientContext* context, const ::dfs::HeartbeatRequest* request, ::dfs::HeartbeatResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ReportBlock(::grpc::ClientContext* context, const ::dfs::ReportBlockRequest* request, ::dfs::ReportBlockResponse* response, std::function<void(::grpc::Status)>) override;
      void ReportBlock(::grpc::ClientContext* context, const ::dfs::ReportBlockRequest* request, ::dfs::ReportBlockResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::dfs::RegisterDataNodeResponse>* AsyncRegisterDataNodeRaw(::grpc::ClientContext* context, const ::dfs::RegisterDataNodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::RegisterDataNodeResponse>* PrepareAsyncRegisterDataNodeRaw(::grpc::ClientContext* context, const ::dfs::RegisterDataNodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::HeartbeatResponse>* AsyncHeartbeatRaw(::grpc::ClientContext* context, const ::dfs::HeartbeatRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::HeartbeatResponse>* PrepareAsyncHeartbeatRaw(::grpc::ClientContext* context, const ::dfs::HeartbeatRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::ReportBlockResponse>* AsyncReportBlockRaw(::grpc::ClientContext* context, const ::dfs::ReportBlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::dfs::ReportBlockResponse>* PrepareAsyncReportBlockRaw(::grpc::ClientContext* context, const ::dfs::ReportBlockRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_RegisterDataNode_;
    const ::grpc::internal::RpcMethod rpcmethod_Heartbeat_;
    const ::grpc::internal::RpcMethod rpcmethod_ReportBlock_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Registro inicial de un DataNode
    virtual ::grpc::Status RegisterDataNode(::grpc::ServerContext* context, const ::dfs::RegisterDataNodeRequest* request, ::dfs::RegisterDataNodeResponse* response);
    // Heartbeat: DataNode avisa que sigue activo
    virtual ::grpc::Status Heartbeat(::grpc::ServerContext* context, const ::dfs::HeartbeatRequest* request, ::dfs::HeartbeatResponse* response);
    // Reporte de bloques almacenados
    virtual ::grpc::Status ReportBlock(::grpc::ServerContext* context, const ::dfs::ReportBlockRequest* request, ::dfs::ReportBlockResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_RegisterDataNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RegisterDataNode() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_RegisterDataNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterDataNode(::grpc::ServerContext* /*context*/, const ::dfs::RegisterDataNodeRequest* /*request*/, ::dfs::RegisterDataNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRegisterDataNode(::grpc::ServerContext* context, ::dfs::RegisterDataNodeRequest* request, ::grpc::ServerAsyncResponseWriter< ::dfs::RegisterDataNodeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Heartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Heartbeat() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_Heartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Heartbeat(::grpc::ServerContext* /*context*/, const ::dfs::HeartbeatRequest* /*request*/, ::dfs::HeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHeartbeat(::grpc::ServerContext* context, ::dfs::HeartbeatRequest* request, ::grpc::ServerAsyncResponseWriter< ::dfs::HeartbeatResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ReportBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ReportBlock() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_ReportBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReportBlock(::grpc::ServerContext* /*context*/, const ::dfs::ReportBlockRequest* /*request*/, ::dfs::ReportBlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReportBlock(::grpc::ServerContext* context, ::dfs::ReportBlockRequest* request, ::grpc::ServerAsyncResponseWriter< ::dfs::ReportBlockResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_RegisterDataNode<WithAsyncMethod_Heartbeat<WithAsyncMethod_ReportBlock<Service > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_RegisterDataNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RegisterDataNode() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::dfs::RegisterDataNodeRequest, ::dfs::RegisterDataNodeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dfs::RegisterDataNodeRequest* request, ::dfs::RegisterDataNodeResponse* response) { return this->RegisterDataNode(context, request, response); }));}
    void SetMessageAllocatorFor_RegisterDataNode(
        ::grpc::MessageAllocator< ::dfs::RegisterDataNodeRequest, ::dfs::RegisterDataNodeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dfs::RegisterDataNodeRequest, ::dfs::RegisterDataNodeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RegisterDataNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterDataNode(::grpc::ServerContext* /*context*/, const ::dfs::RegisterDataNodeRequest* /*request*/, ::dfs::RegisterDataNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RegisterDataNode(
      ::grpc::CallbackServerContext* /*context*/, const ::dfs::RegisterDataNodeRequest* /*request*/, ::dfs::RegisterDataNodeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Heartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Heartbeat() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::dfs::HeartbeatRequest, ::dfs::HeartbeatResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dfs::HeartbeatRequest* request, ::dfs::HeartbeatResponse* response) { return this->Heartbeat(context, request, response); }));}
    void SetMessageAllocatorFor_Heartbeat(
        ::grpc::MessageAllocator< ::dfs::HeartbeatRequest, ::dfs::HeartbeatResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dfs::HeartbeatRequest, ::dfs::HeartbeatResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Heartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Heartbeat(::grpc::ServerContext* /*context*/, const ::dfs::HeartbeatRequest* /*request*/, ::dfs::HeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Heartbeat(
      ::grpc::CallbackServerContext* /*context*/, const ::dfs::HeartbeatRequest* /*request*/, ::dfs::HeartbeatResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ReportBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ReportBlock() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::dfs::ReportBlockRequest, ::dfs::ReportBlockResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::dfs::ReportBlockRequest* request, ::dfs::ReportBlockResponse* response) { return this->ReportBlock(context, request, response); }));}
    void SetMessageAllocatorFor_ReportBlock(
        ::grpc::MessageAllocator< ::dfs::ReportBlockRequest, ::dfs::ReportBlockResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::dfs::ReportBlockRequest, ::dfs::ReportBlockResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ReportBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReportBlock(::grpc::ServerContext* /*context*/, const ::dfs::ReportBlockRequest* /*request*/, ::dfs::ReportBlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ReportBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::dfs::ReportBlockRequest* /*request*/, ::dfs::ReportBlockResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_RegisterDataNode<WithCallbackMethod_Heartbeat<WithCallbackMethod_ReportBlock<Service > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_RegisterDataNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RegisterDataNode() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_RegisterDataNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterDataNode(::grpc::ServerContext* /*context*/, const ::dfs::RegisterDataNodeRequest* /*request*/, ::dfs::RegisterDataNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Heartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Heartbeat() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_Heartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Heartbeat(::grpc::ServerContext* /*context*/, const ::dfs::HeartbeatRequest* /*request*/, ::dfs::HeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ReportBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ReportBlock() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_ReportBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReportBlock(::grpc::ServerContext* /*context*/, const ::dfs::ReportBlockRequest* /*request*/, ::dfs::ReportBlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_RegisterDataNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RegisterDataNode() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_RegisterDataNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterDataNode(::grpc::ServerContext* /*context*/, const ::dfs::RegisterDataNodeRequest* /*request*/, ::dfs::RegisterDataNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRegisterDataNode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Heartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Heartbeat() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_Heartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Heartbeat(::grpc::ServerContext* /*context*/, const ::dfs::HeartbeatRequest* /*request*/, ::dfs::HeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHeartbeat(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ReportBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ReportBlock() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_ReportBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReportBlock(::grpc::ServerContext* /*context*/, const ::dfs::ReportBlockRequest* /*request*/, ::dfs::ReportBlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReportBlock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RegisterDataNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RegisterDataNode() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RegisterDataNode(context, request, response); }));
    }
    ~WithRawCallbackMethod_RegisterDataNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterDataNode(::grpc::ServerContext* /*context*/, const ::dfs::RegisterDataNodeRequest* /*request*/, ::dfs::RegisterDataNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RegisterDataNode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Heartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Heartbeat() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Heartbeat(context, request, response); }));
    }
    ~WithRawCallbackMethod_Heartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Heartbeat(::grpc::ServerContext* /*context*/, const ::dfs::HeartbeatRequest* /*request*/, ::dfs::HeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Heartbeat(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ReportBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ReportBlock() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ReportBlock(context, request, response); }));
    }
    ~WithRawCallbackMethod_ReportBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReportBlock(::grpc::ServerContext* /*context*/, const ::dfs::ReportBlockRequest* /*request*/, ::dfs::ReportBlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ReportBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RegisterDataNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RegisterDataNode() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dfs::RegisterDataNodeRequest, ::dfs::RegisterDataNodeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dfs::RegisterDataNodeRequest, ::dfs::RegisterDataNodeResponse>* streamer) {
                       return this->StreamedRegisterDataNode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RegisterDataNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RegisterDataNode(::grpc::ServerContext* /*context*/, const ::dfs::RegisterDataNodeRequest* /*request*/, ::dfs::RegisterDataNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRegisterDataNode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dfs::RegisterDataNodeRequest,::dfs::RegisterDataNodeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Heartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Heartbeat() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dfs::HeartbeatRequest, ::dfs::HeartbeatResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dfs::HeartbeatRequest, ::dfs::HeartbeatResponse>* streamer) {
                       return this->StreamedHeartbeat(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Heartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Heartbeat(::grpc::ServerContext* /*context*/, const ::dfs::HeartbeatRequest* /*request*/, ::dfs::HeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedHeartbeat(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dfs::HeartbeatRequest,::dfs::HeartbeatResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ReportBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ReportBlock() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::dfs::ReportBlockRequest, ::dfs::ReportBlockResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::dfs::ReportBlockRequest, ::dfs::ReportBlockResponse>* streamer) {
                       return this->StreamedReportBlock(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ReportBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ReportBlock(::grpc::ServerContext* /*context*/, const ::dfs::ReportBlockRequest* /*request*/, ::dfs::ReportBlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReportBlock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::dfs::ReportBlockRequest,::dfs::ReportBlockResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_RegisterDataNode<WithStreamedUnaryMethod_Heartbeat<WithStreamedUnaryMethod_ReportBlock<Service > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_RegisterDataNode<WithStreamedUnaryMethod_Heartbeat<WithStreamedUnaryMethod_ReportBlock<Service > > > StreamedService;
};

}  // namespace dfs


#include <grpcpp/ports_undef.inc>
#endif  // GRPC_dfs_2eproto__INCLUDED
